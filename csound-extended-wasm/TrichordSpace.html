<!DOCTYPE html>
<html>
<head>
<title>Chord Space for Trichords</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<script src="CsoundAudioNode.js"></script>
<script src="csound_loader.js"></script>
<script src='CsoundAC.js'></script>
<script src="js/sprintf.js"></script>
<script src="js/numeric.js"></script>
<script src="js/three.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/tinycolor.js"></script>
<script src="js/dat.gui.js"></script>
<style>
    ::-webkit-scrollbar
    {
        width:10px;
    }
    ::-webkit-scrollbar-track-piece
    {
        opacity:.125;
        background-color:grey;
    }
    ::-webkit-scrollbar-corner
    {
        opacity:.25;
        background-color:grey;
    }
</style>
</head>
<body style="background:black;">
<canvas id="canvas" style="background:transparent;position:absolute;height:100vh;width:100vw;top:0vh;left:0vw;"></canvas>
<table id="table" style="color:white;background-color:transparent;position:absolute;height:25vh;width:100vw;top:0vh;left:0vw;display:block;">
<tr>
<td id="help" style="height:25vh;width:50vw;display:block;overflow:auto;">
<h1>Chord Space for Trichords</h1>
<h3>Michael Gogins<br>3 January 2020</h3>
<p>This program is an interactive 3-dimensional model of a chord space for all 
3-voice chords in 12-tone equal temperament. A chord is a single point in a 
space with 1 dimension for each voice of a chord; thus, any chord space for 
trichords has 3 dimensions. Different equivalence classes divide this space 
into different quotient spaces (or orbifolds), e.g. octave equivalence 
produces a cube, permutational equivalence a prism, transpositional 
equivalence a flat layer, and inversional equivalence a reflection that 
folds half the space over itself. The chord space at startup is the 
combination of octave equivalence and permutational equivalence (OP). See: 
Callendar, Quinn, and Tymoczko, "Generalized Voice-Leading Spaces," 
<b><i>Science</i> 320</b>, 2008.</p>
<p>In OP, the augmented triads form a central column (white balls). It is 
surrounded by 3 columns of major triads (red balls), and 3 columns of minor 
triads (blue balls); each column is a different voicing of the triad. 
Neighboring chords are connected by 1-semitone voice-leadings.<p>
<p>Clicking on a chord selects it, plays it, and prints information about it 
in the text area on the left side. Dragging the mouse with the left button 
down rotates the model, dragging the mouse with the right button down moves 
the model, and dragging the button with the mouse wheel down moves the model 
closer to or farther away from the viewer.<p>
<p>The following commands are available by using the menu (or key 
combinations). Please note, pressing the shift key in a key combination makes 
an up movement into a down movement.
</p>
<dl>
<dt>Equivalence class</dt>
<dd>Sets the current equivalence class of the orbifold. The possibilities are OP 
(octave equivalence and permutational equivalence), OPT (octave equivalence, 
permutational equivalence, and transpositional equivalence; maps to normal form),
or OPTI (octave equivalence, permutational equivalence, transpositional 
equivalence, and inversional equivalence; maps to prime form).<dd>
<dt>Play</dt>
<dd>Starts running the embedded Csound synthesizer, which will play chords as 
they are selected.</dt>
<dt>Stop</dt>
<dd>Stops Csound.</dd>
<dt>Transpose [Alt-T]</dt>
<dd>Transposes the selected chord up (+ key) or down (- key) by 1 semitone.</dd>
<dt>Invert [Alt-I]</dt>
<dd>Inverts the selected chord, i.e. reflects it in the inversion flat that 
divides each OPT domain into two OPTI domains.</dd>
<dt>Move voice 1 [Alt-1]</dt>
<dd>Moves voice 1 of the selected chord up or down by 1 semitone.</dd>
<dt>Move voice 2 [Alt-2]</dt>
<dd>Moves voice 2 of the selected chord up or down by 1 semitone.</dd>
<dt>Move voice 3 [Alt-3]</dt>
<dd>Moves voice 3 of the selected chord up or down by 1 semitone.</dd>
<dt>Neo-Riemannian transformations</dt>
<dd>
<dl>
<dt>Relative [Alt-R]</dt>
<dd>Applies the relative transformation to the selected chord, e.g. I <=> vi./dd>
<dt>Parallel [Alt-P]</dt>
<dd>Applies parallel transformation to the selected chord, e.g. I <=> i.</dd>
<dt>Leading-tone exchange [Alt-L]</dt>
<dd>Applies the leading-tone transformation to the selected chord, e.g. I <=> iii.</dd>
<dt>Slide [Alt-S]</dt>
<dd>Applies the slide transformation to the selected chord, e.g. I <=> i#.</dd>
<dt>Nebenverwandt [Alt-N]</dt>
<dd>Applies the Nebenverwandt transformation to the selected chord, e.g. I <=> iv.</dd>
<dt>Hexpole [Alt-H]</dt>
<dd>Applies the hexpole transformation to the selected chord, e.g. I <=> vib.</dd>
<dd></dd>
</dl>
<dt>Dominant [Alt-D]</dt>
<dd>Not a neo-Reimannian transformation, but transposes the chord down a 
perfect fifth, e.g. V => I.</dd>
</dl>
</td>
<td id="console-layout" >
<textarea id="console" class="w3-container" style="height:25vh;width:50vw;background-color:transparent;border-color:transparent;color:#A9F5A9;font-family:Courier,sans-serif;font-size:9pt;display:block;overflow:auto;">
</textarea>
</td>
</table>
<textarea id="csd" class="w3-code" hidden="true" style="width:100%;height:25vh;box-sizing:border-box;background-color:MidnightBlue;color:NavajoWhite;">
<CsoundSynthesizer>
<CsOptions>
-d -f -m195 -+rtaudio=alsa -odac:plughw:1,0 -iadc:plughw:1,0 --ksmps=128
</CsOptions>
<CsInstruments>
sr = 48000
ksmps = 128
nchnls = 2
nchnls_i = 1
0dbfs = 500000

; Ensure the same random stream for each rendering.
; rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.

;seed 81814
;seed 818145
seed 88818145

connect "Blower", "outleft", "ReverbSC", "inleft"
connect "Blower", "outright", "ReverbSC", "inright"
connect "Bower", "outleft", "ReverbSC", "inleft"
connect "Bower", "outright", "ReverbSC", "inright"
connect "Buzzer", "outleft", "ReverbSC", "inleft"
connect "Buzzer", "outright", "ReverbSC", "inright"
connect "Droner", "outleft", "ReverbSC", "inleft"
connect "Droner", "outright", "ReverbSC", "inright"
connect "FMWaterBell", "outleft", "ReverbSC", "inleft"
connect "FMWaterBell", "outright", "ReverbSC", "inright"
connect "Phaser", "outleft", "ReverbSC", "inleft"
connect "Phaser", "outright", "ReverbSC", "inright"
connect "Sweeper", "outleft", "ReverbSC", "inleft"
connect "Sweeper", "outright", "ReverbSC", "inright"
connect "Shiner", "outleft", "ReverbSC", "inleft"
connect "Shiner", "outright", "ReverbSC", "inright"
connect "ZakianFlute", "outleft", "ReverbSC", "inleft"
connect "ZakianFlute", "outright", "ReverbSC", "inright"
connect "ReverbSC", "outleft", "MasterOutput", "inleft"
connect "ReverbSC", "outright", "MasterOutput", "inright"

alwayson "ReverbSC"
alwayson "MasterOutput"

gk_overlap init 20

prealloc 1, 50
prealloc 2, 50
prealloc 3, 50
prealloc 4, 50
prealloc 5, 50
prealloc 6, 50
prealloc 7, 50
prealloc 8, 20
prealloc 9, 20

gk_ZakianFlute_midi_dynamic_range init 20
gk_ZakianFlute_level init -10
gk_ZakianFlute_pan init .5
gi_ZakianFLute_seed init .5
gif2 ftgen 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
gif26 ftgen 0, 0, 65537, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
gif27 ftgen 0, 0, 65537, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
gif28 ftgen 0, 0, 65537, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
gif29 ftgen 0, 0, 65537, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
gif30 ftgen 0, 0, 65537, -10, 1229, 16, 34, 57, 32
gif31 ftgen 0, 0, 65537, -10, 163, 31, 1, 50, 31
gif32 ftgen 0, 0, 65537, -10, 4128, 883, 354, 79, 59, 23
gif33 ftgen 0, 0, 65537, -10, 1924, 930, 251, 50, 25, 14
gif34 ftgen 0, 0, 65537, -10, 94, 6, 22, 8
gif35 ftgen 0, 0, 65537, -10, 2661, 87, 33, 18
gif36 ftgen 0, 0, 65537, -10, 174, 12
gif37 ftgen 0, 0, 65537, -10, 314, 13
giwtsin ftgen 0, 0, 65537, 10, 1
instr ZakianFlute, 1, 2, 3
; Author: Lee Zakian
; Adapted by: Michael Gogins
i_instrument = p1
i_time = p2
i_duration = abs(p3)
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_overall_amps = 8
i_normalization = ampdb(-i_overall_amps) / 2
i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_ZakianFlute_level)
iattack = .002
isustain = abs(p3)
irelease = .3
ip3 = iattack + isustain + irelease
iHz = cpsmidinn(i_midi_key)
kHz = k(iHz)
aenvelope transeg 1.0, 20.0, -10.0, 0.05
;ip3 = (p3 < 3.0 ? p3 : 3.0)
; parameters
; p4 overall amplitude scaling factor
ip4 init i_amplitude
; p5 pitch in Hertz (normal pitch range: C4-C7)
ip5 init iHz
; p6 percent vibrato depth, recommended values in range [-1., +1.]
ip6 init 0.5
; 0.0 -> no vibrato
; +1. -> 1% vibrato depth, where vibrato rate increases slightly
; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
; p7 attack time in seconds
; recommended value: .12 for slurred notes, .06 for tongued notes
; (.03 for short notes)
ip7 init .08
; p8 decay time in seconds
; recommended value: .1 (.05 for short notes)
ip8 init .08
; p9 overall brightness / filter cutoff factor
; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
ip9 init 5
; initial variables
iampscale = ip4 ; overall amplitude scaling factor
ifreq = ip5 ; pitch in Hertz
ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifiltcut tablei ip9, gif2 ; lowpass filter cutoff frequency
iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
isustain = abs(p3) - iattack - idecay
;p3 = (isustain < 5/kr ? iattack+idecay+5/kr : p3) ; minimal sustain length
isustain = (isustain < 5/kr ? 5/kr : isustain)
iatt = iattack/6
isus = isustain/4
idec = idecay/6
iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
; vibrato block
; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
kvibdepth = kvibdepth* ivibdepth ; vibrato depth
kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibdepth = kvibdepth + kvibdepthr
ivibr1 = gi_ZakianFLute_seed ; vibrato rate
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ivibr2 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
if ip6 < 0 goto vibrato1
kvibrate linseg 2.5+ivibr1, p3, 4.5+ivibr2 ; if p6 positive vibrato gets faster
 goto vibrato2
vibrato1:
ivibr3 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2, p3-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
vibrato2:
kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate = kvibrate + kvibrater
kvib oscili kvibdepth, kvibrate, giwtsin
ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev2 = .003 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev3 = -.0015 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev4 = .012 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
kfreq = kHz * (1 + kfreqr) + kvib
if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
goto range4
; wavetable amplitude envelopes
range1: ; for low range tones
kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
0.172, idec, 0.053, idec, 0
kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
-0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
-0.035, idec, -0.020, idec, 0
kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
0.010, idec, 0.013, idec, 0
iwt1 = gif26 ; wavetable numbers
iwt2 = gif27
iwt3 = gif28
inorm = 3949
goto end
range2: ; for low mid-range tones
kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
0.037, idec, 0.012, idec, 0
kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
-1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
-0.170, idec, -0.065, idec, 0
kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
0.174, idec, -0.027, idec, 0
iwt1 = gif29
iwt2 = gif30
iwt3 = gif31
inorm = 27668.2
goto end
range3: ; for high mid-range tones
kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
idec, 0.031, idec, 0
kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
-0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
-0.003, idec, -0.023, idec, 0
kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
0.167, idec, -0.059, idec, 0
iwt1 = gif32
iwt2 = gif33
iwt3 = gif34
inorm = 3775
goto end
range4: ; for high range tones
kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
idec, 0.028, idec, 0
kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
-0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
-0.071, idec, -0.019, idec, 0
kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
-0.024, idec, 0.002, idec, 0
iwt1 = gif35
iwt2 = gif36
iwt3 = gif37
inorm = 4909.05
goto end
end:
kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp1 = kamp1 + kampr1
kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp2 = kamp2 + kampr2
kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp3 = kamp3 + kampr3
awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
awt2 poscil kamp2, kfreq, iwt2, iphase
awt3 poscil kamp3, kfreq, iwt3, iphase
asig = awt1 + awt2 + awt3
asig = asig*(iampscale/inorm)
kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
afilt tone asig, kcut
a_signal balance afilt, asig
i_attack = .002
i_sustain = p3
i_release = 0.01
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, p7
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

//////////////////////////////////////////////
// Original by Steven Yi.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
gk_FMWaterBell_level init 15
gi_FMWaterBell_attack init 0.002
gi_FMWaterBell_release init 0.01
gi_FMWaterBell_sustain init 20
gi_FMWaterBell_sustain_level init .1
gk_FMWaterBell_index init .5
gk_FMWaterBell_crossfade init .5
gk_FMWaterBell_vibrato_depth init 0.
gk_FMWaterBell_vibrato_rate init 6
gk_FMWaterBell_midi_dynamic_range init 127
gi_FMWaterBell_cosine ftgen 0, 0, 65537, 11, 1
instr FMWaterBell
i_instrument = p1
i_time = p2
i_duration = p3
; One of the envelopes in this instrument should be releasing, and use this:
i_sustain = 1000
xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
i_midi_key = p4
i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
if i_midi_key > 42 goto high_level
i_level_correction = -23.5
goto end_level
high_level:
i_level_correction = -20
end_level:
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
k_gain = ampdb(gk_FMWaterBell_level)
a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
;a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 0
a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, 1, gi_FMWaterBell_release, 0
; ares transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...
; a_envelope transegr 0, gi_FMWaterBell_attack, 12, 1, i_sustain, 12, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 12, 0
a_signal = a_signal * i_amplitude * a_envelope * k_gain
a_out_left, a_out_right pan2 a_signal, p7
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
; printks "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_Droner_partial1 init .1
gk_Droner_partial2 init .1
gk_Droner_partial3 init .3
gk_Droner_partial4 init .2
gk_Droner_partial5 init .1
gk_Droner_level init 16
gi_Droner_sine ftgen 0, 0, 65537, 10, 1, 0, .02
instr Droner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
k1 init .5
k2 init .05
k3 init .1
k4 init .2
k5 init .1
k6 init .05
k7 init .1
k8 init 0
k9 init 0
k10 init 0
k3 = gk_Droner_partial1
k4 = gk_Droner_partial2
k5 = gk_Droner_partial3
k6 = gk_Droner_partial4
k7 = gk_Droner_partial5
kwaveform init 0
iamp = ampdb(ivelocity) 
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
asignal poscil3 1, ihertz, gi_Droner_sine
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
asignal = asignal * kenvelope * 10
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Droner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Sweeper_britel init 0
gk_Sweeper_briteh init 2.9
gk_Sweeper_britels init .2 / 3
gk_Sweeper_britehs init 2.5 / 2
gk_Sweeper_level init 6
gisine ftgen 0, 0, 65537, 10, 1
gioctfn ftgen 0, 0, 65537, -19, 1, 0.5, 270, 0.5
instr Sweeper
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity)
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
icps = ihertz
kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
ktonemoddep jspline 0.01,0.05,0.2
ktonemodrte jspline 6,0.1,0.2
ktone poscil3 ktonemoddep, ktonemodrte, gisine
kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
ibasfreq init icps
ioctcnt init 3
iphs init 0
a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gisine, gioctfn, ioctcnt, iphs
amod poscil3 0.25, ibasfreq*(1/3), gisine
arm = a1*amod
irnd1 = unirand(1)
irnd3 = unirand(3)
kmix expseg 0.001, 0.01, irnd1, irnd3+0.3, 0.001
kmix=.25
a1 ntrpol a1, arm, kmix
;a1 pareq a1/10, 400, 15, .707
;a1 tone a1, 500
kpanrte jspline 5, 0.05, 0.1
kpandep jspline 0.9, 0.2, 0.4
kpan poscil3 kpandep, kpanrte, gisine
a1,a2 pan2 a1, p7
irnd01 = unirand(0.1)
a1 delay a1, irnd01
irnd011 = unirand(0.11)
a2 delay a2, irnd011
kenv linsegr 1, 1, 0
kenv = kenvelope
aleft = a1*kenv*.02
aright = a2*kenv*.02
adamping linsegr 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Sweeper_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Phaser_ratio1 init 1
gk_Phaser_ratio2 init 1/3
gk_Phaser_index1 init 1
gk_Phaser_index2 init 0.0125
gk_Phaser_level init 8
gi_Phaser_sine ftgen 0,0,65537,10,1
instr Phaser
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 8
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
khertz = ihertz
ifunction1 = gi_Phaser_sine
ifunction2 = gi_Phaser_sine
a1,a2 crosspmi gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, khertz, ifunction1, ifunction2
aleft, aright pan2 a1+a2, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft * kenvelope
aright = adamping * aright * kenvelope
kgain = ampdb(gk_Phaser_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Buzzer_harmonics init 15
gk_Buzzer_level init 5
gi_Buzzer_sine ftgen 0, 0, 65537, 10, 1
instr Buzzer
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
gk_Harmonics = gk_Buzzer_harmonics
asignal buzz kenvelope, ihertz, gk_Harmonics, gi_Buzzer_sine
asignal = asignal * 3
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Buzzer_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Shiner_level init 2
instr Shiner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
gk_Harmonics = 1 * 20
asignal vco2 kenvelope * 4, ihertz, 12
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Shiner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Blower_grainDensity init 150
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init .033
gk_Blower_level init 2
gigrtab ftgen 0, 0, 65537, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
giwintab ftgen 0, 0, 65537, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
instr Blower
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
i_phase = p6
i_pan = p6
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
ifrequency = cpsmidinn(i_midikey)
iamplitude = ampdb(i_midivelocity) / 200
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; f1 0 65537 1 "hahaha.aif" 0 4 0
 ; f2 0 1024 7 0 224 1 800 0
 ; f3 0 8192 7 1 8192 -1
 ; f4 0 1024 7 0 512 1 512 0
 ; f5 0 1024 10 1 .3 .1 0 .2 .02 0 .1 .04
 ; f6 0 1024 10 1 0 .5 0 .33 0 .25 0 .2 0 .167
 ; a0 14 50
 ; p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
 ; Start Dur Amp Freq GrTab WinTab FqcRng Dens Fade
 ; i1 0.0 6.5 700 9.00 5 4 .210 200 1.8
 ; i1 3.2 3.5 800 7.08 . 4 .042 100 0.8
 ; i1 5.1 5.2 600 7.10 . 4 .0320 100 0.9
 ; i1 7.2 6.6 900 8.03 . 4 .021 150 1.6
 ; i1 21.3 4.5 1000 9.00 . 4 .031 150 1.2
 ; i1 26.5 13.5 1100 6.09 . 4 .121 150 1.5
 ; i1 30.7 9.3 900 8.05 . 4 .014 150 2.5
 ; i1 34.2 8.8 700 10.02 . 4 .14 150 1.6
iHz = ifrequency
ihertz = iHz
ip4 = iamplitude
ip5 = iHz
ip6 = gigrtab
ip7 = giwintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = iamplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
if p3 == -1 goto indefinite
 goto non_indefinite
indefinite:
 p3 = 1000000
non_indefinite:
iattack = i(gk_overlap) * 2
idecay = i(gk_overlap) * 2
isustain = p3 - i(gk_overlap) * 2
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
kamp = kenvelope
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, gigrtab, giwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, gigrtab, giwintab, 5
aleft = aoutl * kamp * iamplitude
aright = aoutr * kamp * iamplitude
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Blower_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_ReverbSC_feedback init 0.85
gi_ReverbSC_delay_modulation init 0.35
gk_ReverbSC_frequency_cutoff init 15000
instr ReverbSC
ainleft inleta "inleft"
ainright inleta "inright"
; aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]
aoutleft, aoutright reverbsc ainleft, ainright, gk_ReverbSC_feedback, gk_ReverbSC_frequency_cutoff, sr, gi_ReverbSC_delay_modulation
; printks "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aoutleft)), dbamp(rms(aoutright))
outleta "outleft", aoutleft
outleta "outright", aoutright
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_MasterOutput_level init .5
instr MasterOutput
aleft inleta "inleft"
aright inleta "inright"
kgain = ampdb(gk_MasterOutput_level)
outs aleft * kgain, aright * kgain
; fout "Poustinia-v6-7-1.wav", 16, aleft, aright
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

instr exitnow
prints "exitnow i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
 exitnow
endin

</CsInstruments>
<CsScore>
i "exitnow" [5 * 60 + 10 ] .1
</CsScore>
</CsoundSynthesizer>
</textarea>
</div>
<script>
var chord_space = null;
var chord_space_view = null;
try {
    var fs = require("fs");
    var __dirname = fs.realpathSync.native(".");
} catch(e) {
    console.log(e);
}

var csound_message_callback = function(text) {
    var messages_textarea = document.getElementById("console");
    var existing = messages_textarea.value;
    messages_textarea.value = existing + text;
    messages_textarea.scrollTop = messages_textarea.scrollHeight;
};

var draw_fundamental_domain = function(value) {
    if (value === "OP") {
        chord_space = new ChordSpace("RP", 12.);
    }
    if (value === "OPT") {
        chord_space = new ChordSpace("RPTg", 12.);
    }
    if (value === "OPTI") {
        chord_space = new ChordSpace("RPTgI", 12.);
    }
    chord_space_view = new ChordSpaceView(chord_space);
    chord_space_view.draw3D(document.getElementById("canvas"));
    chord_space_view.lookAtFullScene3D();
};

var CsoundAC;
var csound_ = null;
(async function() { 
    CsoundAC = await createCsoundAC(); 
    csound_message_callback(CsoundAC.hello()); 
    var txt = "";
    txt += "Browser CodeName: " + navigator.appCodeName + "\n";
    txt += "Browser Name: " + navigator.appName + "\n";
    txt += "Browser Version: " + navigator.appVersion + "\n";
    txt += "Cookies Enabled: " + navigator.cookieEnabled + "\n";
    txt += "Browser Language: " + navigator.language + "\n";
    txt += "Browser Online: " + navigator.onLine + "\n";
    txt += "Platform: " + navigator.platform + "\n";
    txt += "User-agent header: " + navigator.userAgent + "\n";
    csound_message_callback(txt);
    draw_fundamental_domain("OP");
}());

var title = document.title;

var play_ = async function() {
    try {
        let csd = document.getElementById('csd').value;
        let csound_ = await get_csound(csound_message_callback);
        chord_space_view.csound = csound_;
        await csound_.CompileCsdText(csd);
        await csound_.Start();
        await csound_.Perform();
    } catch(err) {
        csound_message_callback(err.name + ': ' + err.message + ' ' + err.line + '\n');
        alert(err);
    }
}

var stop_ = async function() {
    //let csound_ = await get_csound(csound_message_callback);
    //await csound.Stop();
}

var gk_update = async function(name, value) {
    var numberValue = parseFloat(value);
    //let csound_ = await get_csound(csound_message_callback);
    //csound_.SetControlChannel(name, numberValue);
};

var add_slider = function(gui_folder, token, minimum, maximum, name) {
    var on_parameter_change = function(value) {
        gk_update(token, value);
    };
    gui_folder.add(gui_parameters, token, minimum, maximum).onChange(on_parameter_change);
};

window.addEventListener("unload", function(event) { 
    gui_parameters.stop();
    nw_window.close();
});

var gui_parameters = {
     equivalence_class: 'OP',
     gk_Reverb_feedback: .8,
     gi_Reverb_delay_modulation: 0.5,
     gk_Reverb_frequency_cutoff: 12000.,
     gk_MasterOutput_level: 0.,
     play: function() {play_();},
     stop: function() {stop_();},
     transpose: function() {chord_space_view.controller.transpose(this.semitone);},
     invert: function() {chord_space_view.controller.invert();},
     nrr: function() {chord_space_view.controller.nrr()},
     nrp: function() {chord_space_view.controller.nrp()},
     nrl: function() {chord_space_view.controller.nrl()},
     nrs: function() {chord_space_view.controller.nrs()},
     nrn: function() {chord_space_view.controller.nrn()},
     nrh: function() {chord_space_view.controller.nrh()},
     nrd: function() {chord_space_view.controller.nrd()},
     v1: function() {chord_space_view.controller.v1(this.semitone)},
     v2: function() {chord_space_view.controller.v2(this.semitone)},
     v3: function() {chord_space_view.controller.v3(this.semitone)},
     semitone: 1.,
};

window.addEventListener("load", function() {
    try {
        gui = new dat.GUI({width: 400});
        gui.add(gui_parameters, 'play').name('Play');
        gui.add(gui_parameters, 'stop').name('Stop');
        let Master = gui.addFolder('Master effects');
        add_slider(Master, 'gk_Reverb_feedback', 0, 1);    
        add_slider(Master, 'gi_Reverb_delay_modulation', 0, 3);
        add_slider(Master, 'gk_Reverb_frequency_cutoff', 5000, 20000);
        add_slider(Master, 'gk_MasterOutput_level', -80, 80);
        gui.add(gui_parameters, 'equivalence_class', ['OP', 'OPT', 'OPTI']).name('Equivalence class').onChange(draw_fundamental_domain);
        gui.add(gui_parameters, 'transpose').name('Transpose [Alt-T]');
        gui.add(gui_parameters, 'invert').name('Invert [Alt-I]');
        let Neo_Reimannian = gui.addFolder('Neo-Riemannian Transformations');
        Neo_Reimannian.add(gui_parameters, 'nrr').name('Relative [Alt-R]');
        Neo_Reimannian.add(gui_parameters, 'nrp').name('Parallel [Alt-P]');
        Neo_Reimannian.add(gui_parameters, 'nrl').name('Leading tone exchange [Alt-L]');
        Neo_Reimannian.add(gui_parameters, 'nrs').name('Slide [Alt-S]');
        Neo_Reimannian.add(gui_parameters, 'nrn').name('Nebenverwandt [Alt-N]');
        Neo_Reimannian.add(gui_parameters, 'nrh').name('Hexpole [Alt-H]');
        gui.add(gui_parameters, 'nrd').name('Dominant');
        gui.add(gui_parameters, 'v1').name('Move 1 [Alt-1]');
        gui.add(gui_parameters, 'v2').name('Move 2 [Alt-2]');
        gui.add(gui_parameters, 'v3').name('Move 3 [Alt-3]');
        document.addEventListener("keydown", function (e) {
            const e_char = String.fromCharCode(e.keyCode || e.charCode);
            if (e.shiftKey === true) {
                gui_parameters.semitone = -1;
            } else {
                gui_parameters.semitone = 1.;
            }
            if (e.altKey === true) {
                if        (e_char === 'H') {
                    var table = document.getElementById("table");
                    if (table.style.display === "none") {
                        table.style.display = "block";
                    } else {
                        table.style.display = "none";
                    }
                    gui.closed = true;
                    gui.closed = false;
                } else if (e_char === 'T') {
                    gui_parameters.transpose();
                } else if (e_char === 'I') {
                    gui_parameters.invert();
                } else if (e_char === '1') {
                    gui_parameters.v1();
                } else if (e_char === '2') {
                    gui_parameters.v2();
                } else if (e_char === '3') {
                    gui_parameters.v3();
                } else if (e_char === 'D') {
                    gui_parameters.nrd();
                } else if (e_char === 'R') {
                    gui_parameters.nrr();
                } else if (e_char === 'P') {
                    gui_parameters.nrp();
                } else if (e_char === 'L') {
                    gui_parameters.nrl();
                } else if (e_char === 'S') {
                    gui_parameters.nrs();
                } else if (e_char === 'N') {
                    gui_parameters.nrn();
                } else if (e_char === 'H') {
                    gui_parameters.nrh();
                }
            }
        });
    } catch (e) {
        console.error(e);
    };
});

class ChordSpace {
    constructor(equivalence_class_, range_) {
        csound_message_callback("ChordSpace constructor: " + equivalence_class_ + ", " + range_ + "\n");
        this.equivalence_class = equivalence_class_;
        this.range = range_;
        this.chords = CsoundAC.allOfEquivalenceClass(3, this.equivalence_class, this.range, 1., 0, false);
    }
    contains(a) {
        let n = this.chords.size();
        for (let i = 0; i < n; i++) {
            let b = this.chords.get(i);
            if (a.equals(b)) {
                return true;
            }
        }
        return false;
    }
};

const pickPosition = {x: 0, y: 0};

function getCanvasRelativePosition(event) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (event.clientX - rect.left) * canvas.width  / rect.width,
        y: (event.clientY - rect.top ) * canvas.height / rect.height,
    };
}
 
function setPickPosition(event) {
    try {
        const pos = getCanvasRelativePosition(event);
        pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
        pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
    } catch(x) {
        csound_message_callback(x);
    }
}
 
function clearPickPosition() {
  // unlike the mouse which always has a position
  // if the user stops touching the screen we want
  // to stop picking. For now we just pick a value
  // unlikely to pick something
  pickPosition.x = -100000;
  pickPosition.y = -100000;
}

clearPickPosition();

/**
 * Manages user interactions with the balls in the scene graph that represent 
 * chords. Chords are value types and balls are Three.js reference types.
 */
class ChordSpaceController {
    constructor(view) {
        this.raycaster = new THREE.Raycaster();
        this.pickedObject = null;
        this.pickedObjectSavedColor = 0;
        this.view = view;
        /**
         * Maps Three.js object ids to Chord instances.
         */
        this.chords_for_balls = new Map();
        /**
         * Maps Chord ids to Three.js object ids.
         */
        this.balls_for_chords = new Map();
    }
    /**
     * Returns the chord associated with the object, or undefined if the chord 
     * does not exist.
     */
    chord_for_ball(object_) {
        if (object_ == null) {
            return;
        }
        let id = object_.id;
        let chord = this.chords_for_balls.get(id);
        return chord;
    }
    /**
     * Returns the object associated with the chord, or undefined if the 
     * object does not exist.
     */
    ball_for_chord(chord) {
        if (chord == null) {
            return;
        }
        let chord_id = chord.toString();
        let ball_id = this.balls_for_chords.get(chord_id);
        if (ball_id == null) {
            return;
        }
        let object_ = this.view.scene.getObjectById(ball_id);
        return object_;
    }    
    current_chord() {
        return this.chord_for_ball(this.pickedObject);
    }
    transpose(semitone) {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.T(semitone).eOP();
        this.select_chord(chord);
     }
    invert() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        csound_message_callback(sprintf("invert: chord:      %s\n", chord.toString()));
        let sectors = chord.opt_domain_sectors();
        let sector = sectors.get(0);
        csound_message_callback(sprintf("invert: sector:     %d\n", sector));
        let reflection = chord.reflect(sector).ceiling(1.).eOP();
        csound_message_callback(sprintf("invert: reflection: %s\n", reflection.toString()));
        this.select_chord(reflection);
    }
    nrr() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrR().eOP();
        this.select_chord(chord);
    }
    nrp() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrP().eOP();
        this.select_chord(chord);
    }
    nrl() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrL().eOP();
        this.select_chord(chord);
    }
    nrs() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrS().eOP();
        this.select_chord(chord);
    }
    nrn() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrN().eOP();
        this.select_chord(chord);
    }
    nrh() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.nrH().eOP();
        this.select_chord(chord);
    }
    nrd() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.T(-7).eOP();
        this.select_chord(chord);
    }
    v1(semitone) {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.move(0, semitone).eOP();
        this.select_chord(chord);
    }
    v2(semitone) {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.move(1, semitone).eOP();
        this.select_chord(chord);
    }
    v3(semitone) {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        chord = chord.move(2, semitone).eOP();
        this.select_chord(chord);
    }
    information() {
        let chord = this.current_chord();
        if (chord == null) {
            return;
        }
        let text = chord.information();
        alert(text);
    }
    select_chord(chord) {
        let ball = this.ball_for_chord(chord);
        // Note: "variable == null" is true if the variable is either undefined or null.
        if (ball == null) {
            return;
        }
        this.select_ball(ball);
        this.view.on_picked_chord(chord);
    }
    select_ball(ball) {
        // Restore the state of a previoiusly picked chord.
        if (this.pickedObject !== null) {
            this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
            this.pickedObject.scale.set(1, 1, 1);
            this.pickedObject.material.emissive.multiplyScalar(.5);
        }
        this.pickedObject = ball;
        // Save the state of the picked chord.
        this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
        this.pickedObject.scale.set(1.5, 1.5, 1.5);
        this.pickedObject.material.emissive.multiplyScalar(2.);
        this.view.render();
     }
    pick(normalizedPosition, scene, camera, time) {
        try {
            // Cast a ray through the view frustum.
            this.raycaster.setFromCamera(normalizedPosition, camera);
            // Returns the list of the objects that the ray intersects.
            const intersectedObjects = this.raycaster.intersectObjects(scene.children);
            for (let i = 0; i < intersectedObjects.length; ++i) {
                let picked_ = intersectedObjects[i].object;
                // We are only interested in objects that have associated chords.
                let chord = this.chord_for_ball(picked_);
                if (chord == null) {
                    continue;
                } else {
                    this.select_ball(picked_);
                    break;
                }
            }
            return this.pickedObject;
        } catch(x) {
            csound_message_callback("Exception in ChordSpaceController.pick:\n", x.message);
            return null;
        }
    }
}

class ChordSpaceView {
    constructor(chord_space_) {
        this.chord_space = chord_space_
        this.score = null;
        this.canvas = null;
        this.context = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.major = CsoundAC.chordForName("CM").normal_form();
        this.minor = CsoundAC.chordForName("Cm").normal_form();
        this.augmented = CsoundAC.chordForName("C+").normal_form();
        this.controller = new ChordSpaceController(this);
        this.current_chord = null;
        this.prior_chord = null;
    }
    play_chord() {
        let csound_ = get_csound(csound_message_callback);
        if (csound_ == null) {
            return;
        }
        // Stop playing the prior chord.
        if (this.prior_chord !== null) {
            if (this.current_chord.equals(this.prior_chord)) {
                return;
            }
            for (let voice = 0; voice < this.prior_chord.voices(); ++voice) {
                let instrument = 1. + voice;
                let time = 0.;
                let duration = 0.;
                let key = 60. + this.prior_chord.getPitch(voice);
                let velocity = 60.;
                let x = 0.;
                let y = voice / 4.;
                let z = 0.;
                let event = sprintf("i %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f \n", -instrument, time, duration, key, velocity, x, y, z);
                csound_.ReadScore(event);
            }
        } 
        // Start playing the currrent chord.
        if (this.current_chord == null) {
            return;
        } else {
            for (let voice = 0; voice < this.current_chord.voices(); ++voice) {
                let instrument = 1. + voice;
                let time = 0.;
                let duration = -100.;
                let key = 60 + this.current_chord.getPitch(voice);
                let velocity = 60.;
                let x = 0.;
                let y = voice / 4.;
                let z = 0.;
                let event = sprintf("i %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f \n", instrument, time, duration, key, velocity, x, y, z);
                csound_.ReadScore(event);
            }
        }
    }
    render() {
        this.renderer.render(this.scene, this.camera);
    }
    on_picked_chord(new_chord) {
        this.render();
        csound_message_callback("Picked chord:\n" + new_chord.information() + "\n");
        this.prior_chord = this.current_chord;
        this.current_chord = new_chord;
        this.play_chord();
    }
    prepareScene3D() {
        let canvas = this.canvas;
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        this.scene = new THREE.Scene();
        let scene = this.scene;
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true
        });
        let renderer = this.renderer;
        renderer.setClearColor(0);
        renderer.sortObjects = false;
        renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(canvas.devicePixelRatio);
        // Wire up the view controls to the camera.
        this.camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1, 100000);
        let camera = this.camera;
        this.controls = new THREE.TrackballControls(camera, renderer.domElement);
        let controls = this.controls;
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1;
        controls.panSpeed = 1;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        //controls.keys = [ 65, 83, 68 ];
        var chord_space_view = this;
        this.canvas.addEventListener("mousemove", function(e) {
            chord_space_view.render3D();
        });
        this.canvas.addEventListener("mousedown", function(e) {
            ///csound_message_callback(e.toString() + "\n");
            clearPickPosition();
            setPickPosition(e);
            const picked = chord_space_view.controller.pick(pickPosition, chord_space_view.scene, chord_space_view.camera, 0);
            let chord =  chord_space_view.controller.chord_for_ball(picked);
            if (chord == null) {
                return;
            } else {
                chord_space_view.on_picked_chord(chord);
            }
        });
        // Ensure that all sides are lighted.
        let light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(-1, -2, 11).normalize();
        this.scene.add(light);
        let light2 = new THREE.DirectionalLight(0xffffff, 2);
        light2.position.set(2, 1, -22).normalize();
        this.scene.add(light2);
        var onResize = function() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            this.renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
            this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
            this.controls.handleResize();
            this.camera.updateProjectionMatrix();
            this.renderer.render(this.scene, this.camera);
        };
        window.addEventListener('resize', onResize, false);
    }
    lookAtFront3D() {
        let bounding_box = new THREE.Box3().setFromObject(this.scene);
        this.camera.lookAt(bounding_box.getCenter());
        this.camera.fov = 4 * Math.atan((bounding_box.getSize().y / (this.canvas.width / this.canvas.height)) / (2 * bounding_box.getSize().z)) * (180 / Math.PI);
        this.camera.position.copy(bounding_box.getCenter());
        this.camera.position.x = 6.125 * Math.max(bounding_box.getSize().x, bounding_box.getSize().y);
        this.camera.position.y = this.camera.position.x * 14;
        this.camera.position.z = this.camera.position.x * 24;
        this.controls.target.copy(bounding_box.getCenter());
        this.controls.update();
        this.camera.updateProjectionMatrix();
        this.renderer.render(this.scene, this.camera);
    }
    render3D() {
        this.controls.update();
        this.camera.updateProjectionMatrix();
        this.renderer.render(this.scene, this.camera);
    }
    plotChord3D(chord) {
        let hue;
        let saturation;
        let value;
        let normal_form = chord.normal_form();
        if (normal_form.equals(this.augmented)) {
            hue = 0.;
            saturation = 0.;
            value = .75;
        } else if (normal_form.equals(this.major)) {
            hue = 0.;
            saturation = 1.;
            value = 1.;
        } else if (normal_form.equals(this.minor)) {
            hue = 240./360.;
            saturation = 1.;
            value = 1.;
        } else {
            hue = (chord.getPitch(0) + chord.getPitch(1) * 2.0 + chord.getPitch(2)) / 44.0;
            saturation = 1.0;
            value = .2;
        }
        let color_ = tinycolor.fromRatio({h: hue, s: saturation, v: value}).toHexString();
        let emissive_ = tinycolor.fromRatio({h: hue, s: saturation, v: value / 3.}).toHexString();
        let specular_ = tinycolor.fromRatio({h: hue, s: saturation / 2, v: value / 3.}).toHexString();
        let geometry = new THREE.SphereGeometry(0.125, 12, 12);
        let material = new THREE.MeshPhongMaterial( {specular: specular_, 
        color: color_, emissive: emissive_, side: THREE.DoubleSide} );        
        let ball = new THREE.Mesh(geometry, material);    
        ball.position.x = chord.getPitch(0);
        ball.position.y = chord.getPitch(1);
        ball.position.z = chord.getPitch(2);
        this.scene.add(ball);
        this.controller.balls_for_chords.set(chord.toString(), ball.id);
        this.controller.chords_for_balls.set(ball.id, chord);
        ///csound_message_callback("plotChord3D: normal_form: " + chord.normal_form().toString() + " chord: " + chord.toString() + "\n");
    }
    lookAtFullScene3D() {
        let bounding_box = new THREE.Box3().setFromObject(this.scene);
        this.camera.lookAt(bounding_box.getCenter());
        this.camera.fov = 2 * Math.atan((bounding_box.getSize().x / (this.canvas.width / this.canvas.height)) / (2 * bounding_box.getSize().y)) * (180 / Math.PI);
        this.camera.position.copy(bounding_box.getCenter());
        this.camera.position.z = 6.125 * Math.min(bounding_box.getSize().x, bounding_box.getSize().y);
        this.camera.position.y = this.camera.position.x * 9;
        this.camera.position.z = this.camera.position.x * 9;
        this.controls.target.copy(bounding_box.getCenter());
        this.controls.update();
        this.camera.updateProjectionMatrix();
        this.renderer.render(this.scene, this.camera);
    }
    drawAxes() {
        let range = this.chord_space.range * 1.125;
        const material = new THREE.LineBasicMaterial( { color: "yellow", linewidth: 5 } );    
        const geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(range, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, range, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, range));
        const line = new THREE.Line(geometry, material);
        this.scene.add(line);
        const center_material = new THREE.LineBasicMaterial( { color: "white", linewidth: 5 } );    
        const center_geometry = new THREE.Geometry();
        range = range * .4;
        center_geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(range, range, range));
        const center_line = new THREE.Line(center_geometry, center_material);
        this.scene.add(center_line);
    }
    connect(origin, neighbor) {
        if (this.chord_space.contains(neighbor) === false) {
            return;
        } else {
            const material = new THREE.LineBasicMaterial( { color: "green", linewidth: 3, opacity: .25 } );    
            const geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(origin.getPitch(0), origin.getPitch(1), origin.getPitch(2)), new THREE.Vector3(neighbor.getPitch(0), neighbor.getPitch(1), neighbor.getPitch(2)));
            const line = new THREE.Line(geometry, material);
            this.scene.add(line);
        }
    }
    drawConnections() {
        let n = this.chord_space.chords.size();
        for (let i = 0; i < n; i++) {
            let chord = this.chord_space.chords.get(i);
            this.connect(chord, chord.move(0,  1.).eP());
            this.connect(chord, chord.move(1,  1.).eP());
            this.connect(chord, chord.move(2,  1.).eP());
            this.connect(chord, chord.move(0, -1.).eP());
            this.connect(chord, chord.move(1, -1.).eP());
            this.connect(chord, chord.move(2, -1.).eP());
        }
    }
    draw3D(canvas_) {
        this.canvas = canvas_;
        this.prepareScene3D(canvas_, this.chord_space);
        // Plot the chords.
        let n = this.chord_space.chords.size();
        for (var i = 0; i < n; i++) {
            let chord = this.chord_space.chords.get(i);
            this.plotChord3D(chord);
        }
        this.drawAxes();
        this.drawConnections();
        this.lookAtFullScene3D();
        return canvas;
    }
};

</script>
</body>
</html>
