; B-format Encoding Orchestra
; - Richard W.E. Furse 1995 (richard@muse.demon.co.uk)
;
; This orchestra reads a single mono sound file and produces B-format 
; (or four-channel) output. The mono sound is placed in the B-format 
; soundfield at a location decided by various controlling instruments.
;
; Implemented:
;       <X,Y,Z> coordinate control system: 
;		There are two instrument types: one controls spatialisation
;		using further instruments that generate globals gk0x,gk0y,gk0z
;		etc. The reason for the zero is to allow the instrument set
;		1-9 to be pasted to 11-19, 21-29 etc to allow several
;		spatialised instruments in one orchestra. The global names
;		should be changed to correspond to the new instrument numbers.
;		These instruments allow continuous spatialisation - moving
;		sounds.
;		There is a further instrument (91) that produces a sound and
;		places it at a particular coordinate based on the P-fields
;		passed to it. This instrument produces sounds that do not
;		move, but runs much faster as it does not have to update
;		its scalars continuously.
;       Doppler shift:
;               using delay lines (for moving sounds). The detail of this is
;		not correct as Csound delay lines are a little inflexible.
;		However it doesn't sound too bad.
;       High-frequency attentuation:
;               using arbitrary filter function. No real acoustic basis but
;		again it doesn't sound too bad.
;       Reverb:
;               using mono reverb from Lyon collection. No early reflections
;		or room-modelling is used - the reverb output is fed directly
;               into the omnidirectional channel. The reverberation amount can
;		be changed using instrument 98. The reverberation instrument
;		itself is instrument 99 and should be running whenever anything
;		else is.
;       Distancing:
;               uses an inverse square law for both directional and 
;               omni-directional components of the sound. Clumpy but works 
;               if you don't go too near the centre. Probably mathematically
;		purer than correcting for this. Having said this the static
;		version of the spatialisation instrument (91) does make an
;		attempt.
;
; The orchestra as configured will produce a 4-channel B-Format sound file
; with channels in the order X,W,Y,Z. To produce a 4-speaker feed change
; which outq lines are commented out in all sound-producing instruments.
;
; Simple example score:
;
;	i98	0 1	0.01
;		This sets the reverb level for the piece.
;	i2	0 4	2 2 1	1 0 0
;	i1	4 4	0 360	1 8
;	i9	0 8	1 0
;		The above plays from the beginning of the input soundfile,
;		moves the sound in a straight line from <2,2,1> to <1,0,0>
;		and then rotates it once around the listener moving away
;		from distance 1 to 8 as it rotates.
;	i12	3 4	6 3 -2	-6 -2 1
;	i19	3 4	1 10
;		This plays from 10 seconds into the input soundfile and
;		moves the sound from <6,3,-2> to <-6,-2,0>.
;	i91	6 3	1 15	1 1 1
;		This plays from 15 seconds into the input soundfile and
;		places the sound at <1,1,1>.
;	i99	0 10
;		This provides reverberation.
;
; It is simple enough to modify this orchestra to include instruments in
; the signal chain that manipulate the B-Format signal to tumble, rotate
; or otherwise manipulate the sound field.

sr = 48000
kr = 4800
ksmps = 10
nchnls = 4



; Reverb globals:
garevin	init	0

; Reverb amount - tweak only with good reason - reverb should be constant
; for a particular acoustic (or piece?). It can be changed using instrument 98.
girevamount init 0.015
;girevamount init 0.001 ; as outdoor

gifeed = .5
gilp1 = 1/30
gilp2 = 1/23
gilp3 = 1/41
giroll = 2500






; To use this orchestra, one instrument 9 should be running to generate sound.
; While it is running, and at all times it is running, instruments 1 or 2 or
; similar instruments should be used to decide the exact location of the sound
; being generated by instrument 9. At any one time, only one instrument that
; decides a location should run and one should be running at all times. It is
; possible to use several calls to controlling instruments as long as one takes
; up where another leaves off. Also the reverb unit (instrument 99) should be
; playing at all times that other things are and should be left on for a short
; while after its input ends so that the reverb can decay.
;
; Coordinates are in terms of x, y and z. These are generally considered so
; that positive x is ahead, negative x behind, positive y to the left, negative
; y to the right, positive z above and z negative below. <0,0,0> is therefore
; exactly where the listener is and the nearer the sound gets to this point the
; louder it becomes. Because of this it is worth staying away as signals will
; clip heavily and Csound may crash if a signal passes through <0,0,0>.
;
; Writing new location-control instruments is straightforward - all the
; instrument needs to do is sensibly set gk0x,gk0y and gk0z to the <x,y,z>
; coordinates of the sound.
;
; Note that if sounds move very quickly it may be necessary to change the
; control rate (kr) in the instrument header right up to the audio rate
; because of the use of variable delay lines in instrument 9.


	instr 1
; This is a rotation + distance controller on the x-y plane only - during the
; life of the instrument the angle of the sound is rotated from p4 to p5
; (angles are in degrees and may be beyond 0 or 360 so multiple rotations can be
; achieved in one call.) p6 and p7 are used to vary the overall distance from
; the listener.
;
; Examples:
;
; i1 0 10	0 360	1 1
;	This moves from angle 0 to 360 degrees - ie once around. The distance
;	away from the listener remains at 1 so the sound moves around the unit
;	circle.
; i1 0 10	0 3600	1 7
;	This moves around ten times and moves away from distance 1 to distance 7
;	so it moves away from the listener as it rotates.
;
kangle	linseg	p4*0.0174533,p3,p5*0.0174533
kdist	linseg	p6,p3,p7
gk0x	=	cos(kangle)*kdist
gk0y	=	sin(kangle)*kdist
gk0z	=	0
	endin


	instr 2
; This is a simple movement in a line between two three-dimensional coordinates.
; <x,y,z>=<p4,p5,p6> is the start location and <x,y,z>=<p7,p8,p9> is the end
; location.
;
; Examples:
;
; i2 0 10	0 -5 1	-1 0 0
;	This starts at coordinate <0,-5,1> - ie a long way to the right and
;	slightly above, and moves to <-1,0,0> ie behind and on the listeners
;	level.
;
; i2 0 10	1 1 1	1 1 1
;	This places the sound at <1,1,1> - forwards, above and to the left -
;	and leaves it there.
;
gk0x	linseg	p4,p3,p7
gk0y	linseg	p5,p3,p8
gk0z	linseg	p6,p3,p9
	endin


; A few more obscure paths:	
	instr 3
ks0x	oscil	2,3,1
ks0y	oscil	1,2,1
ks0z	oscil	1,1,1
ky	linseg	4,p3,0
gk0x	=	sin(ks0x)
gk0y	=	cos(ks0x)+ks0y+ky
gk0z	=	ks0z+2.5-ky/4
	endin

	instr 4
ky	linseg	0,p3,80
gk0x	=	(cos(ky))*4-4
gk0z	=	cos(ky)
gk0y	=	(sin(ky))*4+.1
	endin

	instr 5
kq	linseg	0,p3,3.1415*12 ; 6 times round
gk0x	=	cos(kq)*2
gk0y	=	sin(kq)*2
gk0z	=	-1
	endin


	instr 9
; This instrument plays a soundfile, gain modified by p4 and starting 
; playing back the soundfile "input.aiff" from time p5. The soundfile
; played by the instrument is hardcoded in the soundin line below. If the
; filename is replaced with p6 then the additional parameter can be used
; to identify a soundin file.
;
; Example:
;
; i9 0 10	1 0
;
; The location of the sound is decided by controller instruments like the
; above - without a calls to these the system tends to clip and behave
; unpredictably.

; INPUT SOUNDFILE

ain	soundin	"input.aiff",p5
amono	=	ain*p4 ; apply gain
; NB - it is possible to replace the above with a synthesis algorithm. However
; doing motive spatialisation and synthesis simultaneously is slow. Also
; see instrument 91.

; DISTANCE

kd	=	sqrt(gk0x*gk0x+gk0y*gk0y+gk0z*gk0z)
kd0w	=	1/(kd*kd*kd)
kd1g	=	1/(kd*kd)

; FILTER FOR HIGH-FREQUENCY AIR ATTENUATION
;
; - using some extremely arbitrary filtering.

kctrl	=	96000/(kd*kd+4)
afilt	tone	amono,kctrl

; FEED THE FILTERED SIGNAL TO THE REVERB UNIT

garevin	=	garevin+afilt

; DELAY LINE TO INDUCE SOMETHING SIMILAR TO DOPPLER SHIFT & DISTANCE DELAYS

adummy	delayr	5
	delayw	afilt

adel	deltapi	kd/200

; B-FORMAT ENCODING

ax	=	adel*gk0x*kd1g
ay	=	adel*gk0y*kd1g
az	=	adel*gk0z*kd1g
aw	=	adel*0.707*kd0w

; There are alternative versions of the outq command provided depending on the
; type of output required - lines are commented out using the ';' symbol.
; Choose one and only one. Generally B-format output should be used but if you
; want to feed the output immediately to four speakers and not further process
; the soundfile use another outq line to listen to the plane of sound required.

; Uncomment this one for B-format output
	outq ax, aw, ay, az

; Uncomment this to play the x-y plane through a four speaker rig
;	outq aw+(ax*0.707)+(ay*0.707),aw-(ax*0.707)+(ay*0.707),aw-(ax*0.707)-(ay*0.707),aw+(ax*0.707)-(ay*0.707)         

; Uncomment this to play the x-z plane through a four speaker rig
;	outq aw+(ax*0.707)+(az*0.707),aw-(ax*0.707)+(az*0.707),aw-(ax*0.707)-(az*0.707),aw+(ax*0.707)-(az*0.707)         

; Uncomment this to play the y-z plane through a four speaker rig
;	outq aw+(ay*0.707)+(az*0.707),aw-(ay*0.707)+(az*0.707),aw-(ay*0.707)-(az*0.707),aw+(ay*0.707)-(az*0.707)         

	endin


















; Instruments 11-19 are used in the same way as instruments 1-9 to produce a
; second channel of spatialised sound. To produce further channels copy these
; instruments and change the names of globals gk1x, gk1y and gk1z to something
; appropriate.

	instr 11
kangle	linseg	p4*0.0174533,p3,p5*0.0174533
kdist	linseg	p6,p3,p7
gk1x	=	cos(kangle)*kdist
gk1y	=	sin(kangle)*kdist
gk1z	=	0
	endin


	instr 12
gk1x	linseg	p4,p3,p7
gk1y	linseg	p5,p3,p8
gk1z	linseg	p6,p3,p9
	endin


	instr 19
ain	soundin	"input.aiff",p5
amono	=	ain*p4

kd	=	sqrt(gk1x*gk1x+gk1y*gk1y+gk1z*gk1z)
kd0w	=	1/(kd*kd*kd)
kd1g	=	1/(kd*kd)

kctrl	=	96000/(kd*kd+4)
afilt	tone	amono,kctrl

garevin	=	garevin+afilt

adummy	delayr	5
	delayw	afilt

adel	deltapi	kd/200

ax	=	adel*gk1x*kd1g
ay	=	adel*gk1y*kd1g
az	=	adel*gk1z*kd1g
aw	=	adel*0.707*kd0w

; Uncomment this one for B-format output
	outq ax, aw, ay, az

; Uncomment this to play the x-y plane through a four speaker rig
;	outq aw+(ax*0.707)+(ay*0.707),aw-(ax*0.707)+(ay*0.707),aw-(ax*0.707)-(ay*0.707),aw+(ax*0.707)-(ay*0.707)         

; Uncomment this to play the x-z plane through a four speaker rig
;	outq aw+(ax*0.707)+(az*0.707),aw-(ax*0.707)+(az*0.707),aw-(ax*0.707)-(az*0.707),aw+(ax*0.707)-(az*0.707)         

; Uncomment this to play the y-z plane through a four speaker rig
;	outq aw+(ay*0.707)+(az*0.707),aw-(ay*0.707)+(az*0.707),aw-(ay*0.707)-(az*0.707),aw+(ay*0.707)-(az*0.707)         

	endin







        instr 91
; This instrument is similar to instrument 9 etc except that it does not use
; an additional positioning instrument - the location of the sound is specified
; in the call to instrument 91 itself.
;
; The instrument can be easily modified to include a synthesis algorithm as the
; ambisonic overhead is not great as it most calculations are resolved at
; i-time. (I find the instruments 9 etc too slow to use for both sound
; design and spatialisation simultaneously although this is entirely possible.)
;
; Like instruments 9 etc, this instrument plays a soundfile, gain modified by
; p4 and starting playing back the soundfile "input.aiff" from time p5. The
; soundfile played by the instrument is hardcoded in the soundin line below.
; If the filename is replaced with another P-Field then the additional
; parameter can be used to identify a soundin file.
;
; Further to this parameters <p6,p7,p8> specify the <x,y,z> coordinate of the
; sound. The sound does not move.
;
; Example:
;
; i9 0 10	1 0	0 0 1
;	This plays the beginning of a soundfile with unit gain and positions
;	the sound directly above the listener.

;kampc1  linseg  0,.02,p4,p3-.12,p4,0.1,0
;apl     pluck   kampc1,p5,p5,0,1
ain	soundin "input.aiff",p5
apl	=	ain*p4
amono   =       apl

garevin =       garevin+amono

; DISTANCE
;
; Unlike instruments 9 etc this instrument does change its functions when
; sounds are close (<.2) to <0,0,0> so that clipping can be avoided. This
; allows it to be used relatively safely with randomly placed sounds.
idss    =       p6*p6+p7*p7+p8*p8
id      =       sqrt(idss)
if id<.2 igoto close
id0w    =       1/(id*id)
id1g    =       1/(id*id*id)
igoto continue
close:
id0w    =       4/((id+.2)*(id+.2))
id1g    =       625*id
continue:

; FILTER FOR HIGH-FREQUENCY AIR ATTENUATION
;
; - using some extremely arbitrary and brutal filtering

ictrl   =       96000/(id*id+4)
afilt   tone    amono,ictrl

; DELAY LINE FOR DOPPLER ETC

adummy  delay   afilt,id/200

; ENCODING

ivx     =       p6*id1g
ivy     =       p7*id1g
ivz     =       p8*id1g
;ivw    =       0.707*id0w
;ivw    =       id0w
ivw     =       0.354*id0w

ax      =       afilt*ivx
ay      =       afilt*ivy
az      =       afilt*ivz
aw      =       afilt*ivw

; Uncomment this one for B-format output
        outq ax, aw, ay, az

; Uncomment this to play the x-y plane through a four speaker rig
;       outq aw+(ax*0.707)+(ay*0.707),aw-(ax*0.707)+(ay*0.707),aw-(ax*0.707)-(ay*0.707),aw+(ax*0.707)-(ay*0.707)         

; Uncomment this to play the x-z plane through a four speaker rig
;       outq aw+(ax*0.707)+(az*0.707),aw-(ax*0.707)+(az*0.707),aw-(ax*0.707)-(az*0.707),aw+(ax*0.707)-(az*0.707)         

; Uncomment this to play the y-z plane through a four speaker rig
;       outq aw+(ay*0.707)+(az*0.707),aw-(ay*0.707)+(az*0.707),aw-(ay*0.707)-(az*0.707),aw+(ay*0.707)-(az*0.707)         

        endin













; REVERBERATION:

; Instrument 98 is a special instrument which allows the the reverberation
; amount to be changed. The system defaults to 0.015 (see top of program).

	instr 98
girevamount = p4
	endin


	instr 99
; Global reverb

; Not mine - originally came from the Lyon compilation.

	asigin = garevin
	ajunk alpass asigin,.7,.044
	aleft alpass ajunk,.3,.037

	kdel1 randi .01,1,.666
	kdel1 =kdel1 + .02
	adummy2 delayr .5
	afeed1 deltapi kdel1
	afeed1 = afeed1 + gifeed*aleft
		delayw aleft

	;global reverb

	aglobin = (afeed1)*.2
	atap1 comb aglobin,3.3,gilp1
	atap2 comb aglobin,3.3,gilp2
	atap3 comb aglobin,3.3,gilp3
	aglobrev alpass atap1+atap2+atap3,2.6,.085
	aglobrev tone aglobrev,giroll

	kdel3 randi .003,1,.888
	kdel3 =kdel3 + .05
	addl3 delayr .2
	agr1 deltapi kdel3
		delayw aglobrev

	arev = agr1+afeed1
	
; ENCODING

ax	=	0
ay	=	0
az	=	0
aw	=	arev*girevamount

; Uncomment this one for B-format output
	outq ax, aw, ay, az

; Uncomment this to play the x-y plane through a four speaker rig
;	outq aw+(ax*0.707)+(ay*0.707),aw-(ax*0.707)+(ay*0.707),aw-(ax*0.707)-(ay*0.707),aw+(ax*0.707)-(ay*0.707)         

; Uncomment this to play the x-z plane through a four speaker rig
;	outq aw+(ax*0.707)+(az*0.707),aw-(ax*0.707)+(az*0.707),aw-(ax*0.707)-(az*0.707),aw+(ax*0.707)-(az*0.707)         

; Uncomment this to play the y-z plane through a four speaker rig
;	outq aw+(ay*0.707)+(az*0.707),aw-(ay*0.707)+(az*0.707),aw-(ay*0.707)-(az*0.707),aw+(ay*0.707)-(az*0.707)         

garevin = 0

	endin
